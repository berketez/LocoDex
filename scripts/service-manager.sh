#!/bin/bash

# LocoDex Geli≈ümi≈ü Servis Y√∂netimi ve Autostart Sistemi
# T√ºm servisleri otomatik ba≈ülatƒ±r, izler ve y√∂netir

set -e

# Renkler
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Global deƒüi≈ükenler
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
LOG_DIR="$PROJECT_DIR/logs"
PID_DIR="$PROJECT_DIR/pids"
CONFIG_DIR="$PROJECT_DIR/config"
SERVICE_CONFIG="$CONFIG_DIR/services.json"

# Platform tespiti
detect_platform() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        PLATFORM="linux"
        INIT_SYSTEM="systemd"
        SERVICE_DIR="/etc/systemd/system"
        if [ ! -d "$SERVICE_DIR" ]; then
            INIT_SYSTEM="sysv"
            SERVICE_DIR="/etc/init.d"
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        PLATFORM="macos"
        INIT_SYSTEM="launchd"
        SERVICE_DIR="$HOME/Library/LaunchAgents"
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "win32" ]]; then
        PLATFORM="windows"
        INIT_SYSTEM="winsvc"
        SERVICE_DIR="$HOME/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup"
    fi
    
    echo -e "${GREEN}üîç Platform: $PLATFORM ($INIT_SYSTEM)${NC}"
}

# Log fonksiyonu
log() {
    local service_name="${2:-system}"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') [$service_name] - $1" | tee -a "$LOG_DIR/service-manager.log"
}

# Servis yapƒ±landƒ±rmasƒ±nƒ± olu≈ütur
create_service_config() {
    if [ ! -f "$SERVICE_CONFIG" ]; then
        log "${BLUE}‚öôÔ∏è  Servis yapƒ±landƒ±rmasƒ± olu≈üturuluyor...${NC}"
        
        mkdir -p "$CONFIG_DIR"
        
        cat > "$SERVICE_CONFIG" << EOF
{
  "version": "1.0.0",
  "platform": "$PLATFORM",
  "autostart": true,
  "services": {
    "locodex-api": {
      "name": "LocoDex API Server",
      "description": "LocoDex ana API servisi",
      "enabled": true,
      "autostart": true,
      "type": "node",
      "workingDir": "$PROJECT_DIR",
      "command": "npm run start:api",
      "env": {
        "NODE_ENV": "production",
        "PORT": "8000"
      },
      "ports": [8000],
      "dependencies": [],
      "healthCheck": {
        "url": "http://localhost:8000/health",
        "interval": 30,
        "timeout": 10,
        "retries": 3
      },
      "restart": {
        "policy": "always",
        "delay": 5,
        "maxRetries": 5
      },
      "logging": {
        "file": "$LOG_DIR/api.log",
        "level": "info",
        "maxSize": "10MB",
        "maxFiles": 5
      }
    },
    "locodex-vllm": {
      "name": "LocoDex VLLM Service",
      "description": "LocoDex VLLM inference servisi",
      "enabled": true,
      "autostart": true,
      "type": "python",
      "workingDir": "$PROJECT_DIR/src/services/vllm_service",
      "command": "python3 server.py",
      "env": {
        "PYTHONPATH": "$PROJECT_DIR/src/services/vllm_service",
        "HOST": "0.0.0.0",
        "PORT": "8080"
      },
      "ports": [8080],
      "dependencies": [],
      "healthCheck": {
        "url": "http://localhost:8080/health",
        "interval": 60,
        "timeout": 15,
        "retries": 3
      },
      "restart": {
        "policy": "on-failure",
        "delay": 10,
        "maxRetries": 3
      },
      "logging": {
        "file": "$LOG_DIR/vllm.log",
        "level": "info",
        "maxSize": "50MB",
        "maxFiles": 3
      }
    },
    "locodex-web": {
      "name": "LocoDex Web Frontend",
      "description": "LocoDex web aray√ºz√º",
      "enabled": true,
      "autostart": true,
      "type": "node",
      "workingDir": "$PROJECT_DIR",
      "command": "npm run preview",
      "env": {
        "NODE_ENV": "production",
        "PORT": "3000"
      },
      "ports": [3000],
      "dependencies": ["locodex-api"],
      "healthCheck": {
        "url": "http://localhost:3000",
        "interval": 30,
        "timeout": 10,
        "retries": 3
      },
      "restart": {
        "policy": "always",
        "delay": 5,
        "maxRetries": 5
      },
      "logging": {
        "file": "$LOG_DIR/web.log",
        "level": "info",
        "maxSize": "10MB",
        "maxFiles": 3
      }
    },
    "locodex-training": {
      "name": "LocoDex Training Service",
      "description": "LocoDex model eƒüitimi servisi",
      "enabled": false,
      "autostart": false,
      "type": "python",
      "workingDir": "$PROJECT_DIR/src/services/training_service",
      "command": "python3 main.py",
      "env": {
        "PYTHONPATH": "$PROJECT_DIR/src/services/training_service"
      },
      "ports": [8081],
      "dependencies": [],
      "healthCheck": {
        "url": "http://localhost:8081/health",
        "interval": 120,
        "timeout": 30,
        "retries": 2
      },
      "restart": {
        "policy": "no",
        "delay": 0,
        "maxRetries": 0
      },
      "logging": {
        "file": "$LOG_DIR/training.log",
        "level": "debug",
        "maxSize": "100MB",
        "maxFiles": 2
      }
    },
    "locodex-deep-research": {
      "name": "LocoDex Deep Research",
      "description": "LocoDex derin ara≈ütƒ±rma servisi",
      "enabled": false,
      "autostart": false,
      "type": "python",
      "workingDir": "$PROJECT_DIR/src/services/deep_research_service",
      "command": "python3 server.py",
      "env": {
        "PYTHONPATH": "$PROJECT_DIR/src/services/deep_research_service"
      },
      "ports": [8082],
      "dependencies": [],
      "healthCheck": {
        "url": "http://localhost:8082/health",
        "interval": 60,
        "timeout": 15,
        "retries": 2
      },
      "restart": {
        "policy": "on-failure",
        "delay": 15,
        "maxRetries": 2
      },
      "logging": {
        "file": "$LOG_DIR/deep-research.log",
        "level": "info",
        "maxSize": "25MB",
        "maxFiles": 3
      }
    }
  },
  "monitoring": {
    "enabled": true,
    "interval": 30,
    "alerts": {
      "email": false,
      "desktop": true,
      "webhook": false
    }
  },
  "backup": {
    "enabled": true,
    "interval": "daily",
    "retention": 7,
    "path": "$PROJECT_DIR/backups"
  }
}
EOF
        
        log "${GREEN}‚úÖ Servis yapƒ±landƒ±rmasƒ± olu≈üturuldu${NC}"
    fi
}

# Ortamƒ± hazƒ±rla
setup_environment() {
    log "${BLUE}üèóÔ∏è  Servis ortamƒ± hazƒ±rlanƒ±yor...${NC}"
    
    mkdir -p "$LOG_DIR"
    mkdir -p "$PID_DIR" 
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$PROJECT_DIR/backups"
    
    # Log dosyalarƒ±nƒ± olu≈ütur
    touch "$LOG_DIR/service-manager.log"
    touch "$LOG_DIR/api.log"
    touch "$LOG_DIR/vllm.log"
    touch "$LOG_DIR/web.log"
    touch "$LOG_DIR/training.log"
    touch "$LOG_DIR/deep-research.log"
    
    # Log rotasyonu i√ßin logrotate yapƒ±landƒ±rmasƒ±
    create_logrotate_config
    
    log "${GREEN}‚úÖ Servis ortamƒ± hazƒ±r${NC}"
}

# Log rotasyon yapƒ±landƒ±rmasƒ±
create_logrotate_config() {
    if [ "$PLATFORM" = "linux" ]; then
        cat > "$CONFIG_DIR/locodex-logrotate" << EOF
$LOG_DIR/*.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    create 644 $USER $USER
    postrotate
        # Servisleri restart etmek yerine sadece log dosyalarƒ±nƒ± yeniden a√ß
        systemctl reload locodex-* 2>/dev/null || true
    endscript
}
EOF
    fi
}

# Port kontrol√º
check_port() {
    local port="$1"
    if command -v lsof &> /dev/null; then
        lsof -i:$port > /dev/null 2>&1
    elif command -v netstat &> /dev/null; then
        netstat -ln | grep ":$port " > /dev/null 2>&1
    else
        false
    fi
}

# Portu temizle
kill_port() {
    local port="$1"
    log "${YELLOW}üîÑ Port $port temizleniyor...${NC}"
    
    if command -v lsof &> /dev/null; then
        lsof -ti:$port | xargs kill -9 2>/dev/null || true
    elif command -v fuser &> /dev/null; then
        fuser -k $port/tcp 2>/dev/null || true
    fi
    
    sleep 2
}

# Servis saƒülƒ±k kontrol√º
health_check() {
    local service_name="$1"
    local service_config=$(jq -r ".services.\"$service_name\"" "$SERVICE_CONFIG")
    
    if [ "$service_config" = "null" ]; then
        return 1
    fi
    
    local health_url=$(echo "$service_config" | jq -r '.healthCheck.url')
    local timeout=$(echo "$service_config" | jq -r '.healthCheck.timeout')
    
    if [ "$health_url" != "null" ]; then
        if curl -f -s --max-time "$timeout" "$health_url" > /dev/null 2>&1; then
            return 0
        fi
    fi
    
    return 1
}

# Baƒüƒ±mlƒ±lƒ±klarƒ± kontrol et
check_dependencies() {
    local service_name="$1"
    local dependencies=$(jq -r ".services.\"$service_name\".dependencies[]?" "$SERVICE_CONFIG" 2>/dev/null)
    
    for dep in $dependencies; do
        if ! is_service_running "$dep"; then
            log "${YELLOW}‚ö†Ô∏è  Baƒüƒ±mlƒ±lƒ±k √ßalƒ±≈ümƒ±yor: $dep${NC}" "$service_name"
            return 1
        fi
    done
    
    return 0
}

# Servis √ßalƒ±≈üƒ±yor mu kontrol et
is_service_running() {
    local service_name="$1"
    local pid_file="$PID_DIR/$service_name.pid"
    
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        else
            rm -f "$pid_file"
        fi
    fi
    
    return 1
}

# Servis ba≈ülat
start_service() {
    local service_name="$1"
    local service_config=$(jq -r ".services.\"$service_name\"" "$SERVICE_CONFIG")
    
    if [ "$service_config" = "null" ]; then
        log "${RED}‚ùå Servis bulunamadƒ±: $service_name${NC}"
        return 1
    fi
    
    # Servis zaten √ßalƒ±≈üƒ±yor mu?
    if is_service_running "$service_name"; then
        log "${YELLOW}‚ö†Ô∏è  Servis zaten √ßalƒ±≈üƒ±yor: $service_name${NC}"
        return 0
    fi
    
    # Servis aktif mi?
    local enabled=$(echo "$service_config" | jq -r '.enabled')
    if [ "$enabled" != "true" ]; then
        log "${YELLOW}‚ö†Ô∏è  Servis devre dƒ±≈üƒ±: $service_name${NC}"
        return 0
    fi
    
    # Baƒüƒ±mlƒ±lƒ±klarƒ± kontrol et
    if ! check_dependencies "$service_name"; then
        log "${RED}‚ùå Baƒüƒ±mlƒ±lƒ±klar hazƒ±r deƒüil: $service_name${NC}"
        return 1
    fi
    
    # Servis bilgilerini al
    local working_dir=$(echo "$service_config" | jq -r '.workingDir')
    local command=$(echo "$service_config" | jq -r '.command')
    local log_file=$(echo "$service_config" | jq -r '.logging.file')
    local ports=$(echo "$service_config" | jq -r '.ports[]?' 2>/dev/null)
    
    # Portlarƒ± kontrol et ve gerekirse temizle
    for port in $ports; do
        if check_port "$port"; then
            kill_port "$port"
        fi
    done
    
    log "${BLUE}üöÄ Servis ba≈ülatƒ±lƒ±yor: $service_name${NC}" "$service_name"
    
    # √áalƒ±≈üma dizinine ge√ß
    cd "$working_dir"
    
    # Environment variables'ƒ± ayarla
    local env_vars=$(echo "$service_config" | jq -r '.env | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)
    while IFS= read -r env_var; do
        if [ ! -z "$env_var" ]; then
            export "$env_var"
        fi
    done <<< "$env_vars"
    
    # Servisi ba≈ülat (arka planda)
    nohup $command > "$log_file" 2>&1 &
    local pid=$!
    
    # PID'i kaydet
    echo "$pid" > "$PID_DIR/$service_name.pid"
    
    # Ba≈ülatma kontrol√º
    sleep 3
    if kill -0 "$pid" 2>/dev/null; then
        log "${GREEN}‚úÖ Servis ba≈ülatƒ±ldƒ±: $service_name (PID: $pid)${NC}" "$service_name"
        
        # Saƒülƒ±k kontrol√º (opsiyonel)
        local retries=5
        while [ $retries -gt 0 ]; do
            if health_check "$service_name"; then
                log "${GREEN}‚úÖ Saƒülƒ±k kontrol√º ba≈üarƒ±lƒ±: $service_name${NC}" "$service_name"
                break
            fi
            ((retries--))
            if [ $retries -gt 0 ]; then
                log "${YELLOW}‚è≥ Saƒülƒ±k kontrol√º bekleniyor... ($retries kalan)${NC}" "$service_name"
                sleep 5
            fi
        done
        
        return 0
    else
        log "${RED}‚ùå Servis ba≈ülatƒ±lamadƒ±: $service_name${NC}" "$service_name"
        rm -f "$PID_DIR/$service_name.pid"
        return 1
    fi
}

# Servis durdur
stop_service() {
    local service_name="$1"
    local force="${2:-false}"
    
    if ! is_service_running "$service_name"; then
        log "${YELLOW}‚ö†Ô∏è  Servis zaten durmu≈ü: $service_name${NC}"
        return 0
    fi
    
    local pid_file="$PID_DIR/$service_name.pid"
    local pid=$(cat "$pid_file")
    
    log "${BLUE}üõë Servis durduruluyor: $service_name (PID: $pid)${NC}" "$service_name"
    
    # Graceful shutdown
    if [ "$force" = "false" ]; then
        kill -TERM "$pid" 2>/dev/null || true
        
        # 10 saniye bekle
        local wait_time=10
        while [ $wait_time -gt 0 ] && kill -0 "$pid" 2>/dev/null; do
            sleep 1
            ((wait_time--))
        done
    fi
    
    # Hala √ßalƒ±≈üƒ±yorsa zorla durdur
    if kill -0 "$pid" 2>/dev/null; then
        log "${YELLOW}üî® Zorla durduruluyor: $service_name${NC}" "$service_name"
        kill -KILL "$pid" 2>/dev/null || true
    fi
    
    # PID dosyasƒ±nƒ± temizle
    rm -f "$pid_file"
    
    # Port temizliƒüi
    local service_config=$(jq -r ".services.\"$service_name\"" "$SERVICE_CONFIG")
    local ports=$(echo "$service_config" | jq -r '.ports[]?' 2>/dev/null)
    for port in $ports; do
        if check_port "$port"; then
            kill_port "$port"
        fi
    done
    
    log "${GREEN}‚úÖ Servis durduruldu: $service_name${NC}" "$service_name"
}

# Servis yeniden ba≈ülat
restart_service() {
    local service_name="$1"
    
    log "${BLUE}üîÑ Servis yeniden ba≈ülatƒ±lƒ±yor: $service_name${NC}" "$service_name"
    
    stop_service "$service_name"
    sleep 2
    start_service "$service_name"
}

# T√ºm servisleri ba≈ülat
start_all_services() {
    log "${BLUE}üöÄ T√ºm servisler ba≈ülatƒ±lƒ±yor...${NC}"
    
    # Servis listesini al (autostart=true olanlar)
    local services=$(jq -r '.services | to_entries[] | select(.value.autostart == true) | .key' "$SERVICE_CONFIG")
    
    # Baƒüƒ±mlƒ±lƒ±k sƒ±rasƒ±na g√∂re ba≈ülat
    local started_services=()
    local remaining_services=($services)
    
    while [ ${#remaining_services[@]} -gt 0 ]; do
        local progress_made=false
        local new_remaining=()
        
        for service in "${remaining_services[@]}"; do
            if check_dependencies "$service"; then
                start_service "$service"
                started_services+=("$service")
                progress_made=true
            else
                new_remaining+=("$service")
            fi
        done
        
        remaining_services=("${new_remaining[@]}")
        
        if [ "$progress_made" = "false" ] && [ ${#remaining_services[@]} -gt 0 ]; then
            log "${RED}‚ùå Dairesel baƒüƒ±mlƒ±lƒ±k veya eksik baƒüƒ±mlƒ±lƒ±k: ${remaining_services[*]}${NC}"
            break
        fi
    done
    
    log "${GREEN}‚úÖ Autostart servisleri ba≈ülatƒ±ldƒ±${NC}"
}

# T√ºm servisleri durdur
stop_all_services() {
    log "${BLUE}üõë T√ºm servisler durduruluyor...${NC}"
    
    # √áalƒ±≈üan servisleri bul
    local running_services=()
    for pid_file in "$PID_DIR"/*.pid; do
        if [ -f "$pid_file" ]; then
            local service_name=$(basename "$pid_file" .pid)
            if is_service_running "$service_name"; then
                running_services+=("$service_name")
            fi
        fi
    done
    
    # Ters sƒ±rada durdur (baƒüƒ±mlƒ±lƒ±klarƒ± √∂nce)
    for ((i=${#running_services[@]}-1; i>=0; i--)); do
        stop_service "${running_services[i]}"
    done
    
    log "${GREEN}‚úÖ T√ºm servisler durduruldu${NC}"
}

# Servis durumunu g√∂ster
show_service_status() {
    local service_name="$1"
    
    if [ -z "$service_name" ]; then
        # T√ºm servislerin durumunu g√∂ster
        echo -e "${BLUE}üìä Servis Durumu:${NC}"
        echo -e "${BLUE}==================${NC}"
        
        local services=$(jq -r '.services | keys[]' "$SERVICE_CONFIG")
        
        printf "%-20s %-10s %-8s %-15s %-10s\n" "SERVƒ∞S" "DURUM" "PID" "SAƒûLIK" "PORT"
        printf "%-20s %-10s %-8s %-15s %-10s\n" "--------------------" "----------" "--------" "---------------" "----------"
        
        for service in $services; do
            local status="‚ùå Durmu≈ü"
            local pid="N/A"
            local health="‚ùå K√∂t√º"
            local ports=$(jq -r ".services.\"$service\".ports[]?" "$SERVICE_CONFIG" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            
            if is_service_running "$service"; then
                status="‚úÖ √áalƒ±≈üƒ±yor"
                pid=$(cat "$PID_DIR/$service.pid")
                
                if health_check "$service"; then
                    health="‚úÖ ƒ∞yi"
                fi
            fi
            
            printf "%-20s %-10s %-8s %-15s %-10s\n" "$service" "$status" "$pid" "$health" "$ports"
        done
    else
        # Belirli bir servisin detaylƒ± durumu
        echo -e "${BLUE}üìä Servis Detayƒ±: $service_name${NC}"
        echo -e "${BLUE}==============================${NC}"
        
        local service_config=$(jq -r ".services.\"$service_name\"" "$SERVICE_CONFIG")
        if [ "$service_config" = "null" ]; then
            echo -e "${RED}‚ùå Servis bulunamadƒ±: $service_name${NC}"
            return 1
        fi
        
        echo "Adƒ±: $(echo "$service_config" | jq -r '.name')"
        echo "A√ßƒ±klama: $(echo "$service_config" | jq -r '.description')"
        echo "Tip: $(echo "$service_config" | jq -r '.type')"
        echo "Aktif: $(echo "$service_config" | jq -r '.enabled')"
        echo "Otomatik Ba≈ülat: $(echo "$service_config" | jq -r '.autostart')"
        echo "Komut: $(echo "$service_config" | jq -r '.command')"
        echo "√áalƒ±≈üma Dizini: $(echo "$service_config" | jq -r '.workingDir')"
        echo "Portlar: $(echo "$service_config" | jq -r '.ports[]?' 2>/dev/null | tr '\n' ', ' | sed 's/, $//')"
        
        if is_service_running "$service_name"; then
            local pid=$(cat "$PID_DIR/$service_name.pid")
            echo "Durum: ‚úÖ √áalƒ±≈üƒ±yor (PID: $pid)"
            
            if health_check "$service_name"; then
                echo "Saƒülƒ±k: ‚úÖ ƒ∞yi"
            else
                echo "Saƒülƒ±k: ‚ùå K√∂t√º"
            fi
        else
            echo "Durum: ‚ùå Durmu≈ü"
        fi
    fi
}

# Servis izleme (monitoring)
monitor_services() {
    log "${BLUE}üëÄ Servis izleme ba≈ülatƒ±lƒ±yor...${NC}"
    
    local monitor_pid_file="$PID_DIR/monitor.pid"
    echo $$ > "$monitor_pid_file"
    
    # ƒ∞zleme d√∂ng√ºs√º
    while true; do
        local services=$(jq -r '.services | to_entries[] | select(.value.autostart == true) | .key' "$SERVICE_CONFIG")
        
        for service in $services; do
            if ! is_service_running "$service"; then
                log "${RED}üíÄ Servis √ß√∂km√º≈ü: $service${NC}" "monitor"
                
                # Restart policy kontrol et
                local restart_policy=$(jq -r ".services.\"$service\".restart.policy" "$SERVICE_CONFIG")
                
                if [ "$restart_policy" = "always" ] || [ "$restart_policy" = "on-failure" ]; then
                    log "${YELLOW}üîÑ Servis yeniden ba≈ülatƒ±lƒ±yor: $service${NC}" "monitor"
                    start_service "$service"
                fi
            elif ! health_check "$service"; then
                log "${YELLOW}‚ö†Ô∏è  Saƒülƒ±k kontrol√º ba≈üarƒ±sƒ±z: $service${NC}" "monitor"
                
                # 3 kez ba≈üarƒ±sƒ±z saƒülƒ±k kontrol√ºnden sonra restart
                local fail_count_file="$PID_DIR/$service.fails"
                local fail_count=0
                
                if [ -f "$fail_count_file" ]; then
                    fail_count=$(cat "$fail_count_file")
                fi
                
                ((fail_count++))
                echo "$fail_count" > "$fail_count_file"
                
                if [ $fail_count -ge 3 ]; then
                    log "${RED}üîÑ √áoklu saƒülƒ±k kontrol√º ba≈üarƒ±sƒ±z, restart: $service${NC}" "monitor"
                    restart_service "$service"
                    rm -f "$fail_count_file"
                fi
            else
                # Saƒülƒ±k iyi, fail count'u sƒ±fƒ±rla
                rm -f "$PID_DIR/$service.fails"
            fi
        done
        
        sleep 30  # 30 saniyede bir kontrol et
    done
}

# Sistem autostart kurulumu
setup_system_autostart() {
    log "${BLUE}üîÑ Sistem autostart kuruluyor...${NC}"
    
    case $INIT_SYSTEM in
        "systemd")
            # Systemd service dosyasƒ± olu≈ütur
            cat > "$CONFIG_DIR/locodex.service" << EOF
[Unit]
Description=LocoDex AI Services
After=network.target

[Service]
Type=forking
User=$USER
WorkingDirectory=$PROJECT_DIR
ExecStart=$SCRIPT_DIR/service-manager.sh start-all
ExecStop=$SCRIPT_DIR/service-manager.sh stop-all
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
            
            # Service'i kur
            sudo cp "$CONFIG_DIR/locodex.service" "$SERVICE_DIR/"
            sudo systemctl daemon-reload
            sudo systemctl enable locodex.service
            
            log "${GREEN}‚úÖ Systemd autostart kuruldu${NC}"
            ;;
            
        "launchd")
            # LaunchAgent plist dosyasƒ± olu≈ütur
            cat > "$SERVICE_DIR/com.locodex.services.plist" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.locodex.services</string>
    <key>ProgramArguments</key>
    <array>
        <string>$SCRIPT_DIR/service-manager.sh</string>
        <string>start-all</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>WorkingDirectory</key>
    <string>$PROJECT_DIR</string>
    <key>StandardOutPath</key>
    <string>$LOG_DIR/autostart.log</string>
    <key>StandardErrorPath</key>
    <string>$LOG_DIR/autostart.log</string>
</dict>
</plist>
EOF
            
            # LaunchAgent'ƒ± y√ºkle
            launchctl load "$SERVICE_DIR/com.locodex.services.plist"
            
            log "${GREEN}‚úÖ LaunchAgent autostart kuruldu${NC}"
            ;;
            
        "winsvc")
            # Windows i√ßin startup script
            cat > "$SERVICE_DIR/LocoDex.bat" << EOF
@echo off
cd /d "$PROJECT_DIR"
"$SCRIPT_DIR/service-manager.sh" start-all
EOF
            
            log "${GREEN}‚úÖ Windows autostart kuruldu${NC}"
            ;;
    esac
}

# Backup alma
backup_services() {
    log "${BLUE}üíæ Servis backup'ƒ± alƒ±nƒ±yor...${NC}"
    
    local backup_dir="$PROJECT_DIR/backups/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    # Konfig√ºrasyon dosyalarƒ±nƒ± backup'la
    cp -r "$CONFIG_DIR" "$backup_dir/"
    
    # Log dosyalarƒ±nƒ± backup'la (son 24 saat)
    find "$LOG_DIR" -name "*.log" -mtime -1 -exec cp {} "$backup_dir/" \;
    
    # PID dosyalarƒ±nƒ± backup'la
    cp -r "$PID_DIR" "$backup_dir/" 2>/dev/null || true
    
    # Backup'ƒ± sƒ±kƒ±≈ütƒ±r
    tar -czf "$backup_dir.tar.gz" -C "$PROJECT_DIR/backups" "$(basename "$backup_dir")"
    rm -rf "$backup_dir"
    
    log "${GREEN}‚úÖ Backup alƒ±ndƒ±: $backup_dir.tar.gz${NC}"
    
    # Eski backup'larƒ± temizle (7 g√ºnden eski)
    find "$PROJECT_DIR/backups" -name "*.tar.gz" -mtime +7 -delete
}

# Ana fonksiyon
main() {
    detect_platform
    setup_environment
    create_service_config
    
    case "${1:-help}" in
        "start")
            if [ -n "$2" ]; then
                start_service "$2"
            else
                echo "Kullanƒ±m: $0 start <servis_adƒ±>"
                exit 1
            fi
            ;;
        "stop")
            if [ -n "$2" ]; then
                stop_service "$2"
            else
                echo "Kullanƒ±m: $0 stop <servis_adƒ±>"
                exit 1
            fi
            ;;
        "restart")
            if [ -n "$2" ]; then
                restart_service "$2"
            else
                echo "Kullanƒ±m: $0 restart <servis_adƒ±>"
                exit 1
            fi
            ;;
        "start-all")
            start_all_services
            ;;
        "stop-all")
            stop_all_services
            ;;
        "restart-all")
            stop_all_services
            sleep 3
            start_all_services
            ;;
        "status")
            show_service_status "$2"
            ;;
        "monitor")
            monitor_services
            ;;
        "setup-autostart")
            setup_system_autostart
            ;;
        "backup")
            backup_services
            ;;
        "logs")
            if [ -n "$2" ]; then
                tail -f "$LOG_DIR/$2.log"
            else
                tail -f "$LOG_DIR"/*.log
            fi
            ;;
        "clean")
            log "${BLUE}üßπ PID dosyalarƒ± temizleniyor...${NC}"
            rm -f "$PID_DIR"/*.pid
            rm -f "$PID_DIR"/*.fails
            log "${GREEN}‚úÖ Temizlik tamamlandƒ±${NC}"
            ;;
        "help"|"-h"|"--help")
            echo -e "${BLUE}LocoDex Servis Y√∂neticisi Kullanƒ±mƒ±:${NC}"
            echo
            echo -e "${YELLOW}Komutlar:${NC}"
            echo "  start <servis>        - Servisi ba≈ülat"
            echo "  stop <servis>         - Servisi durdur"
            echo "  restart <servis>      - Servisi yeniden ba≈ülat"
            echo "  start-all             - T√ºm servisleri ba≈ülat"
            echo "  stop-all              - T√ºm servisleri durdur"
            echo "  restart-all           - T√ºm servisleri yeniden ba≈ülat"
            echo "  status [servis]       - Servis durumunu g√∂ster"
            echo "  monitor               - Servisleri izle"
            echo "  setup-autostart       - Sistem autostart kur"
            echo "  backup                - Servis backup'ƒ± al"
            echo "  logs [servis]         - Loglarƒ± izle"
            echo "  clean                 - PID dosyalarƒ±nƒ± temizle"
            echo "  help                  - Bu yardƒ±m mesajƒ±"
            echo
            echo -e "${YELLOW}Servisler:${NC}"
            if [ -f "$SERVICE_CONFIG" ]; then
                jq -r '.services | keys[]' "$SERVICE_CONFIG" | sed 's/^/  /'
            fi
            ;;
        *)
            echo "Bilinmeyen komut: $1"
            echo "Yardƒ±m i√ßin: $0 help"
            exit 1
            ;;
    esac
}

# Script √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ±nda ana fonksiyonu ba≈ülat
main "$@"